name: Deploy to Server

on:
  workflow_call:
    inputs:
      image_version:
        description: 'Docker image version to deploy'
        required: false
        default: 'v1.0.0'
        type: string
      push_to_registry:
        description: 'Whether the image was pushed to registry'
        required: false
        default: false
        type: boolean
    secrets:
      SSH_HOST:
        required: true
      SSH_USER:
        required: true
      SSH_PRIVATE_KEY:
        required: true
      DEPLOY_PATH:
        required: true
      GHCR_USERNAME:
        required: false
      GHCR_PAT:
        required: false
      DB_USERNAME:
        required: false
      DB_PASSWORD:
        required: false
      REGISTRY_HOST:
        required: false
      REGISTRY_USERNAME:
        required: false
      REGISTRY_TOKEN:
        required: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Validate deployment secrets
        run: |
          if [ -z "${{ secrets.SSH_HOST }}" ]; then
            echo "Error: SSH_HOST no configurado"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_USER }}" ]; then
            echo "Error: SSH_USER no configurado"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "Error: SSH_PRIVATE_KEY no configurado"
            exit 1
          fi
          if [ -z "${{ secrets.DEPLOY_PATH }}" ]; then
            echo "Error: DEPLOY_PATH no configurado"
            exit 1
          fi

      - name: Checkout project repository
        uses: actions/checkout@v4
        with:
          path: project

      - name: Checkout deployment templates
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/workflow-templates
          path: templates
          token: ${{ github.token }}

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Guardar la SSH key de forma segura
          cat > ~/.ssh/deploy_key << 'EOF'
          ${{ secrets.SSH_PRIVATE_KEY }}
          EOF
          
          chmod 600 ~/.ssh/deploy_key
          
          # Agregar el host a known_hosts
          ssh-keyscan -H "${{ secrets.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Configurar SSH config para usar la key
          cat > ~/.ssh/config << 'SSHCONFIG'
          Host deploy-server
              HostName ${{ secrets.SSH_HOST }}
              User ${{ secrets.SSH_USER }}
              IdentityFile ~/.ssh/deploy_key
              StrictHostKeyChecking accept-new
              UserKnownHostsFile ~/.ssh/known_hosts
          SSHCONFIG
          
          chmod 600 ~/.ssh/config

      - name: Generate version info
        id: version
        run: |
          PROJECT_NAME=$(basename ${{ github.repository }})
          IMAGE_VERSION="${{ inputs.image_version }}"
          
          # Si no se proporciona versión, usa el short SHA
          if [ -z "$IMAGE_VERSION" ] || [ "$IMAGE_VERSION" = "latest" ]; then
            IMAGE_VERSION="v1.0.0"
          fi
          
          echo "project-name=${PROJECT_NAME}" >> $GITHUB_OUTPUT
          echo "image-version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          # Determinar la URI de la imagen basada en el registry usado
          if [ "${{ secrets.GHCR_USERNAME }}" != "" ] && [ "${{ secrets.GHCR_PAT }}" != "" ]; then
            IMAGE_URI="ghcr.io/${{ github.repository_owner }}/${PROJECT_NAME}:${IMAGE_VERSION}"
          elif [ "${{ secrets.REGISTRY_HOST }}" != "" ]; then
            IMAGE_URI="${{ secrets.REGISTRY_HOST }}/${{ github.repository_owner }}/${PROJECT_NAME}:${IMAGE_VERSION}"
          else
            IMAGE_URI="ghcr.io/${{ github.repository_owner }}/${PROJECT_NAME}:${IMAGE_VERSION}"
          fi
          
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT

      - name: Create directories on server
        run: |
          PROJECT_NAME="${{ steps.version.outputs.project-name }}"
          DEPLOY_BASE="${{ secrets.DEPLOY_PATH }}"
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${PROJECT_NAME}"
          
          echo "Creating directories on remote server..."
          ssh -i ~/.ssh/deploy_key "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" << 'SETUP_DIRS'
          set -e
          
          DEPLOY_BASE='${{ secrets.DEPLOY_PATH }}'
          PROJECT_NAME='${{ steps.version.outputs.project-name }}'
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${PROJECT_NAME}"
          
          echo "Creating base directory: $DEPLOY_BASE..."
          mkdir -p "$DEPLOY_BASE"
          chmod 755 "$DEPLOY_BASE"
          
          echo "Creating project directory: $DEPLOY_PROJECT_PATH..."
          mkdir -p "$DEPLOY_PROJECT_PATH"
          chmod 755 "$DEPLOY_PROJECT_PATH"
          
          echo "Directories created successfully!"
          ls -la "$DEPLOY_BASE"
          SETUP_DIRS

      - name: Download Docker image artifact (if not pushed to registry)
        if: ${{ !inputs.push_to_registry }}
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ steps.version.outputs.image-version }}
          path: ./

      - name: Copy deployment files to server
        run: |
          PROJECT_NAME="${{ steps.version.outputs.project-name }}"
          DEPLOY_BASE="${{ secrets.DEPLOY_PATH }}"
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${PROJECT_NAME}"
          
          echo "Uploading docker-compose.yml to $DEPLOY_PROJECT_PATH..."
          scp -i ~/.ssh/deploy_key project/docker-compose.yml "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${DEPLOY_PROJECT_PATH}/" 2>/dev/null || {
            echo "Warning: Failed to upload docker-compose.yml, continuing..."
          }
          
          # Si no se usa registry, subir la imagen como archivo
          if [ "${{ inputs.push_to_registry }}" = "false" ] && [ -f "image.tar" ]; then
            echo "Uploading Docker image to server..."
            scp -i ~/.ssh/deploy_key image.tar "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${DEPLOY_PROJECT_PATH}/"
          fi
          
          echo "Uploading .env file if exists..."
          if [ -f "project/.env" ]; then
            scp -i ~/.ssh/deploy_key project/.env "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${DEPLOY_BASE}/" 2>/dev/null || {
              echo "Warning: Failed to upload .env, continuing..."
            }
          else
            echo "INFO: .env not found in project, using server's existing .env"
          fi

      - name: Deploy application
        run: |
          DEPLOY_BASE="${{ secrets.DEPLOY_PATH }}"
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${{ steps.version.outputs.project-name }}"
          DOCKER_IMAGE="${{ steps.version.outputs.image-uri }}"
          PROJECT_NAME="${{ steps.version.outputs.project-name }}"
          
          echo "Deploying $PROJECT_NAME with image: $DOCKER_IMAGE"
          
          ssh -i ~/.ssh/deploy_key "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" << 'DEPLOY_SCRIPT'
          set -e
          
          DEPLOY_BASE='${{ secrets.DEPLOY_PATH }}'
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${{ steps.version.outputs.project-name }}"
          DOCKER_IMAGE='${{ steps.version.outputs.image-uri }}'
          PROJECT_NAME='${{ steps.version.outputs.project-name }}'
          
          echo "================================"
          echo "Starting deployment..."
          echo "================================"
          echo "Project: $PROJECT_NAME"
          echo "Image: $DOCKER_IMAGE"
          echo "Deploy Base: $DEPLOY_BASE"
          echo "Project Path: $DEPLOY_PROJECT_PATH"
          echo ""
          
          cd "$DEPLOY_PROJECT_PATH"
          
          # Exportar variables para docker-compose
          export DOCKER_IMAGE="$DOCKER_IMAGE"
          export PROJECT_NAME="$PROJECT_NAME"
          export APP_NAME="$PROJECT_NAME"  # Para compatibilidad con docker-compose existentes
          export COMPOSE_PROJECT_NAME="$PROJECT_NAME"
          
          # Variables de base de datos
          export DB_USERNAME='${{ secrets.DB_USERNAME }}'
          export DB_PASSWORD='${{ secrets.DB_PASSWORD }}'
          export DB_JDBC_URL="${DB_JDBC_URL:-jdbc:postgresql://localhost:5432/${PROJECT_NAME}}"
          
          echo "Environment variables exported:"
          echo "  DOCKER_IMAGE=$DOCKER_IMAGE"
          echo "  PROJECT_NAME=$PROJECT_NAME"
          echo "  APP_NAME=$APP_NAME"
          echo "  DB_USERNAME=$DB_USERNAME"
          echo ""
          
          PUSH_TO_REGISTRY='${{ inputs.push_to_registry }}'
          
          # Si no se usa registry, cargar imagen desde archivo
          if [ "$PUSH_TO_REGISTRY" = "false" ] && [ -f "image.tar" ]; then
            echo "Loading Docker image from file..."
            docker load -i image.tar
            echo "Image loaded successfully"
          else
            # Si se usa registry, autenticarse y hacer pull
            REGISTRY_HOST='${{ secrets.REGISTRY_HOST }}'
            REGISTRY_USERNAME='${{ secrets.REGISTRY_USERNAME }}'
            REGISTRY_TOKEN='${{ secrets.REGISTRY_TOKEN }}'
            GHCR_USERNAME='${{ secrets.GHCR_USERNAME }}'
            GHCR_PAT='${{ secrets.GHCR_PAT }}'

            # Intentar autenticarse con GHCR si hay credenciales
            if [ -n "$GHCR_USERNAME" ] && [ -n "$GHCR_PAT" ]; then
              echo "Logging in to GHCR (ghcr.io)..."
              echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin && {
                echo "GHCR authentication successful"
              } || {
                echo "ERROR: Failed to authenticate with GHCR"
                exit 1
              }
            elif [ -n "$REGISTRY_USERNAME" ] && [ -n "$REGISTRY_TOKEN" ]; then
              # Alternativa: autenticarse con registro genérico
              RH="${REGISTRY_HOST:-ghcr.io}"
              echo "Logging in to $RH as $REGISTRY_USERNAME..."
              echo "$REGISTRY_TOKEN" | docker login "$RH" -u "$REGISTRY_USERNAME" --password-stdin && {
                echo "Registry authentication successful"
              } || {
                echo "ERROR: Failed to authenticate with registry"
                exit 1
              }
            else
              echo "WARNING: No registry credentials provided - attempting to pull public image"
            fi

            echo "Pulling image from registry..."
            docker-compose pull || {
              echo "WARNING: Failed to pull image, attempting to start with cached image..."
            }
          fi

          # Si existe docker-compose.yml, ejecutar el script de deploy
          if [ -f "docker-compose.yml" ]; then
            echo ""
            echo "Starting containers..."
            docker-compose up -d || {
              echo "ERROR: Failed to start containers"
              docker-compose logs
              exit 1
            }

            echo ""
            echo "Showing container status..."
            docker-compose ps

            echo ""
            echo "Application deployed successfully!"
          else
            echo "ERROR: docker-compose.yml not found in $DEPLOY_PROJECT_PATH"
            exit 1
          fi
          DEPLOY_SCRIPT

      - name: Verify deployment
        run: |
          DEPLOY_BASE="${{ secrets.DEPLOY_PATH }}"
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${{ steps.version.outputs.project-name }}"
          
          echo "Checking application status..."
          ssh -i ~/.ssh/deploy_key "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" << 'VERIFY_SCRIPT'
          DEPLOY_PROJECT_PATH='$DEPLOY_PROJECT_PATH'
          
          cd "$DEPLOY_PROJECT_PATH"
          
          echo "Current docker-compose status:"
          docker-compose ps || true
          
          echo ""
          echo "Recent logs (last 30 lines):"
          docker-compose logs --tail=30 || true
          VERIFY_SCRIPT

      - name: Deployment summary
        if: success()
        run: |
          echo "================================"
          echo "Deployment completed successfully!"
          echo "================================"
          echo ""
          echo "Project: ${{ steps.version.outputs.project-name }}"
          echo "Image: ${{ steps.version.outputs.image-uri }}"
          echo "Deploy Base: ${{ secrets.DEPLOY_PATH }}"
          echo "Server: ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}"

      - name: Deployment failed
        if: failure()
        run: |
          echo "================================"
          echo "Deployment failed!"
          echo "================================"
          echo ""
          echo "Please check the logs above for more details"
          echo ""
          echo "Common issues:"
          echo "  - SSH_PRIVATE_KEY is not formatted correctly"
          echo "  - docker-compose.yml is missing"
          echo "  - Insufficient permissions on the server"
          echo "  - GHCR_USERNAME and GHCR_PAT not configured"
          echo "  - Image is private and credentials missing"
          echo ""
          echo "To fix:"
          echo "  1. Check SSH key format (should be Ed25519 or RSA)"
          echo "  2. Verify GHCR_USERNAME and GHCR_PAT secrets exist"
          echo "  3. Ensure docker-compose.yml exists in project root"
          echo "  4. Check DB_USERNAME and DB_PASSWORD are set"
          exit 1