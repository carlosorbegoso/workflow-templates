name: Deploy to Server

on:
  workflow_call:
    inputs:
      image_version:
        description: 'Docker image version to deploy'
        required: false
        default: 'v1.0.0'
        type: string
      push_to_registry:
        description: 'Whether the image was pushed to registry'
        required: false
        default: false
        type: boolean
    secrets:
      SSH_HOST:
        required: true
      SSH_USER:
        required: true
      SSH_PRIVATE_KEY:
        required: true
      DEPLOY_PATH:
        required: true
      GHCR_USERNAME:
        required: false
      GHCR_PAT:
        required: false
      DB_USERNAME:
        required: false
      DB_PASSWORD:
        required: false
      REGISTRY_HOST:
        required: false
      REGISTRY_USERNAME:
        required: false
      REGISTRY_TOKEN:
        required: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Validate deployment secrets
        run: |
          if [ -z "${{ secrets.SSH_HOST }}" ]; then
            echo "Error: SSH_HOST no configurado"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_USER }}" ]; then
            echo "Error: SSH_USER no configurado"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "Error: SSH_PRIVATE_KEY no configurado"
            exit 1
          fi
          if [ -z "${{ secrets.DEPLOY_PATH }}" ]; then
            echo "Error: DEPLOY_PATH no configurado"
            exit 1
          fi

      - name: Checkout project repository
        uses: actions/checkout@v4
        with:
          path: project

      - name: Checkout deployment templates
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/workflow-templates
          path: templates
          token: ${{ github.token }}
          sparse-checkout: |
            scripts/
          sparse-checkout-cone-mode: false

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Guardar la SSH key de forma segura
          cat > ~/.ssh/deploy_key << 'EOF'
          ${{ secrets.SSH_PRIVATE_KEY }}
          EOF
          
          chmod 600 ~/.ssh/deploy_key
          
          # Agregar el host a known_hosts
          ssh-keyscan -H "${{ secrets.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Configurar SSH config para usar la key
          cat > ~/.ssh/config << 'SSHCONFIG'
          Host deploy-server
              HostName ${{ secrets.SSH_HOST }}
              User ${{ secrets.SSH_USER }}
              IdentityFile ~/.ssh/deploy_key
              StrictHostKeyChecking accept-new
              UserKnownHostsFile ~/.ssh/known_hosts
          SSHCONFIG
          
          chmod 600 ~/.ssh/config

      - name: Generate version info
        id: version
        run: |
          PROJECT_NAME=$(basename ${{ github.repository }})
          IMAGE_VERSION="${{ inputs.image_version }}"
          
          # Si no se proporciona versión, usa el short SHA
          if [ -z "$IMAGE_VERSION" ] || [ "$IMAGE_VERSION" = "latest" ]; then
            IMAGE_VERSION="v0.0.1-$(date +%Y%m%d).$(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
          fi
          
          echo "project-name=${PROJECT_NAME}" >> $GITHUB_OUTPUT
          echo "image-version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          # Generar tag dinámico basado en el commit actual
          COMMIT_SHA="${{ github.sha }}"
          SHORT_SHA="${COMMIT_SHA:0:7}"
          BRANCH_NAME="${{ github.ref_name }}"
          
          # Crear tag dinámico (usar solo los primeros 7 caracteres como en push.yml)
          if [ "$BRANCH_NAME" = "main" ]; then
            DYNAMIC_TAG="main-${SHORT_SHA}"
          else
            DYNAMIC_TAG="${BRANCH_NAME}-${SHORT_SHA}"
          fi
          
          # Si se proporciona una versión específica, usarla
          if [ -n "$IMAGE_VERSION" ] && [ "$IMAGE_VERSION" != "latest" ]; then
            FINAL_TAG="$IMAGE_VERSION"
          else
            FINAL_TAG="$DYNAMIC_TAG"
          fi
          
          # Determinar la URI de la imagen
          if [ "${{ secrets.GHCR_USERNAME }}" != "" ] && [ "${{ secrets.GHCR_PAT }}" != "" ]; then
            IMAGE_URI="ghcr.io/${{ github.repository_owner }}/${PROJECT_NAME}:${FINAL_TAG}"
          elif [ "${{ secrets.REGISTRY_HOST }}" != "" ]; then
            IMAGE_URI="${{ secrets.REGISTRY_HOST }}/${{ github.repository_owner }}/${PROJECT_NAME}:${FINAL_TAG}"
          else
            IMAGE_URI="ghcr.io/${{ github.repository_owner }}/${PROJECT_NAME}:${FINAL_TAG}"
          fi
          
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "final-tag=${FINAL_TAG}" >> $GITHUB_OUTPUT
          echo "Generated image URI: ${IMAGE_URI}"

      - name: Create directories on server
        run: |
          PROJECT_NAME="${{ steps.version.outputs.project-name }}"
          DEPLOY_BASE="${{ secrets.DEPLOY_PATH }}"
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${PROJECT_NAME}"
          
          echo "Creating directories on remote server..."
          ssh -i ~/.ssh/deploy_key "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" << 'SETUP_DIRS'
          set -e
          
          DEPLOY_BASE='${{ secrets.DEPLOY_PATH }}'
          PROJECT_NAME='${{ steps.version.outputs.project-name }}'
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${PROJECT_NAME}"
          
          echo "Creating base directory: $DEPLOY_BASE..."
          mkdir -p "$DEPLOY_BASE"
          chmod 755 "$DEPLOY_BASE"
          
          echo "Creating project directory: $DEPLOY_PROJECT_PATH..."
          mkdir -p "$DEPLOY_PROJECT_PATH"
          chmod 755 "$DEPLOY_PROJECT_PATH"
          
          echo "Directories created successfully!"
          ls -la "$DEPLOY_BASE"
          SETUP_DIRS

      - name: Download Docker image artifact (if not pushed to registry)
        if: ${{ !inputs.push_to_registry }}
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ steps.version.outputs.image-version }}
          path: ./

      - name: Copy deployment files to server
        run: |
          PROJECT_NAME="${{ steps.version.outputs.project-name }}"
          DEPLOY_BASE="${{ secrets.DEPLOY_PATH }}"
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${PROJECT_NAME}"
          
          echo "=== Copying deployment files ==="
          echo "Project: $PROJECT_NAME"
          echo "Deploy path: $DEPLOY_PROJECT_PATH"
          echo ""
          
          # Solo copiar docker-compose.yml del proyecto
          echo "Uploading docker-compose.yml to $DEPLOY_PROJECT_PATH..."
          if [ -f "project/docker-compose.yml" ]; then
            scp -i ~/.ssh/deploy_key project/docker-compose.yml "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${DEPLOY_PROJECT_PATH}/" || {
              echo "ERROR: Failed to upload docker-compose.yml"
              exit 1
            }
            echo "✅ docker-compose.yml uploaded successfully"
          else
            echo "ERROR: docker-compose.yml not found in project root"
            echo "Files in project directory:"
            ls -la project/
            echo ""
            echo "REQUIRED: Create docker-compose.yml in your project root"
            echo "You can use examples/yape-hub-docker-compose.yml as template"
            exit 1
          fi
          
          # Solo copiar imagen si no se usa registry
          if [ "${{ inputs.push_to_registry }}" = "false" ] && [ -f "image.tar" ]; then
            echo "Uploading Docker image to server..."
            scp -i ~/.ssh/deploy_key image.tar "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${DEPLOY_PROJECT_PATH}/"
            echo "✅ Docker image uploaded"
          fi
          
          # Solo copiar .env del proyecto si existe
          echo "Checking for .env file..."
          if [ -f "project/.env" ]; then
            echo "Uploading .env file..."
            scp -i ~/.ssh/deploy_key project/.env "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${DEPLOY_PROJECT_PATH}/" || {
              echo "Warning: Failed to upload .env, continuing..."
            }
            echo "✅ .env uploaded"
          else
            echo "INFO: .env not found in project, server will use existing .env or defaults"
          fi
          
          echo ""
          echo "=== Files copied successfully ==="

      - name: Deploy application
        run: |
          DEPLOY_BASE="${{ secrets.DEPLOY_PATH }}"
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${{ steps.version.outputs.project-name }}"
          DOCKER_IMAGE="${{ steps.version.outputs.image-uri }}"
          PROJECT_NAME="${{ steps.version.outputs.project-name }}"
          
          echo "Deploying $PROJECT_NAME with image: $DOCKER_IMAGE"
          
          ssh -i ~/.ssh/deploy_key "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" << 'DEPLOY_SCRIPT'
          set -e
          
          DEPLOY_BASE='${{ secrets.DEPLOY_PATH }}'
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${{ steps.version.outputs.project-name }}"
          DOCKER_IMAGE='${{ steps.version.outputs.image-uri }}'
          PROJECT_NAME='${{ steps.version.outputs.project-name }}'
          
          echo "================================"
          echo "Starting deployment..."
          echo "================================"
          echo "Project: $PROJECT_NAME"
          echo "Image: $DOCKER_IMAGE"
          echo "Deploy Base: $DEPLOY_BASE"
          echo "Project Path: $DEPLOY_PROJECT_PATH"
          echo ""
          
          cd "$DEPLOY_PROJECT_PATH"
          
          # Exportar variables para docker-compose
          export DOCKER_IMAGE="$DOCKER_IMAGE"
          export PROJECT_NAME="$PROJECT_NAME"
          export APP_NAME="$PROJECT_NAME"  # Para compatibilidad con docker-compose existentes
          export COMPOSE_PROJECT_NAME="$PROJECT_NAME"
          
          # Variables de base de datos
          export DB_USERNAME='${{ secrets.DB_USERNAME }}'
          export DB_PASSWORD='${{ secrets.DB_PASSWORD }}'
          export DB_JDBC_URL="${DB_JDBC_URL:-jdbc:postgresql://localhost:5432/${PROJECT_NAME}}"
          
          echo "Environment variables exported:"
          echo "  DOCKER_IMAGE=$DOCKER_IMAGE"
          echo "  PROJECT_NAME=$PROJECT_NAME"
          echo "  APP_NAME=$APP_NAME"
          echo "  DB_USERNAME=$DB_USERNAME"
          echo ""
          
          PUSH_TO_REGISTRY='${{ inputs.push_to_registry }}'
          
          # Si no se usa registry, cargar imagen desde archivo
          if [ "$PUSH_TO_REGISTRY" = "false" ] && [ -f "image.tar" ]; then
            echo "Loading Docker image from file..."
            docker load -i image.tar
            echo "Image loaded successfully"
          else
            # Si se usa registry, autenticarse y hacer pull
            REGISTRY_HOST='${{ secrets.REGISTRY_HOST }}'
            REGISTRY_USERNAME='${{ secrets.REGISTRY_USERNAME }}'
            REGISTRY_TOKEN='${{ secrets.REGISTRY_TOKEN }}'
            GHCR_USERNAME='${{ secrets.GHCR_USERNAME }}'
            GHCR_PAT='${{ secrets.GHCR_PAT }}'

            # Intentar autenticarse con GHCR si hay credenciales
            if [ -n "$GHCR_USERNAME" ] && [ -n "$GHCR_PAT" ]; then
              echo "Logging in to GHCR (ghcr.io)..."
              echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin && {
                echo "GHCR authentication successful"
              } || {
                echo "ERROR: Failed to authenticate with GHCR"
                exit 1
              }
            elif [ -n "$REGISTRY_USERNAME" ] && [ -n "$REGISTRY_TOKEN" ]; then
              # Alternativa: autenticarse con registro genérico
              RH="${REGISTRY_HOST:-ghcr.io}"
              echo "Logging in to $RH as $REGISTRY_USERNAME..."
              echo "$REGISTRY_TOKEN" | docker login "$RH" -u "$REGISTRY_USERNAME" --password-stdin && {
                echo "Registry authentication successful"
              } || {
                echo "ERROR: Failed to authenticate with registry"
                exit 1
              }
            else
              echo "WARNING: No registry credentials provided - attempting to pull public image"
            fi

            echo "Checking available images in GHCR..."
            
            # Intentar listar imágenes disponibles (requiere autenticación)
            echo "Available tags for $PROJECT_NAME:"
            
            # Intentar diferentes tags comunes (nativo y JVM)
            SHORT_SHA="${{ github.sha }}"
            SHORT_SHA_7="${SHORT_SHA:0:7}"
            BRANCH_NAME="${{ github.ref_name }}"
            
            POSSIBLE_TAGS=(
              "${{ steps.version.outputs.final-tag }}"
              "${BRANCH_NAME}-${SHORT_SHA_7}"
              "${BRANCH_NAME}-jvm-${SHORT_SHA_7}"
              "${BRANCH_NAME}-${SHORT_SHA}"
              "${BRANCH_NAME}-jvm-${SHORT_SHA}"
              "latest"
              "v1.0.0"
            )
            
            FOUND_IMAGE=""
            for tag in "${POSSIBLE_TAGS[@]}"; do
              TEST_IMAGE="ghcr.io/${{ github.repository_owner }}/${PROJECT_NAME}:${tag}"
              echo "Testing image: $TEST_IMAGE"
              
              if docker manifest inspect "$TEST_IMAGE" >/dev/null 2>&1; then
                echo "✅ Found working image: $TEST_IMAGE"
                FOUND_IMAGE="$TEST_IMAGE"
                break
              else
                echo "❌ Image not found: $TEST_IMAGE"
              fi
            done
            
            if [ -n "$FOUND_IMAGE" ]; then
              echo "Using found image: $FOUND_IMAGE"
              export DOCKER_IMAGE="$FOUND_IMAGE"
            else
              echo "ERROR: No valid image found. Trying original image anyway..."
              export DOCKER_IMAGE="$DOCKER_IMAGE"
            fi
            
            echo "Final DOCKER_IMAGE: $DOCKER_IMAGE"
            
            echo "Pulling image from registry..."
            if ! docker-compose pull; then
              echo "ERROR: Failed to pull image from registry"
              echo "Checking docker-compose.yml content:"
              cat docker-compose.yml
              echo ""
              echo "Checking available local images:"
              docker images | grep "$PROJECT_NAME" || echo "No $PROJECT_NAME images found locally"
              echo ""
              echo "Last attempt - trying to pull image directly:"
              docker pull "$DOCKER_IMAGE" || {
                echo "Direct pull also failed"
                echo "This usually means:"
                echo "1. The image doesn't exist in the registry"
                echo "2. Authentication failed"
                echo "3. The build step didn't complete successfully"
                exit 1
              }
            fi
          fi

          # Si existe docker-compose.yml, ejecutar el script de deploy
          if [ -f "docker-compose.yml" ]; then
            echo ""
            echo "Starting containers..."
            docker-compose up -d || {
              echo "ERROR: Failed to start containers"
              docker-compose logs
              exit 1
            }

            echo ""
            echo "Showing container status..."
            docker-compose ps

            echo ""
            echo "Application deployed successfully!"
          else
            echo "ERROR: docker-compose.yml not found in $DEPLOY_PROJECT_PATH"
            exit 1
          fi
          DEPLOY_SCRIPT

      - name: Verify deployment
        run: |
          DEPLOY_BASE="${{ secrets.DEPLOY_PATH }}"
          DEPLOY_PROJECT_PATH="${DEPLOY_BASE}/${{ steps.version.outputs.project-name }}"
          
          echo "Checking application status..."
          ssh -i ~/.ssh/deploy_key "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" << 'VERIFY_SCRIPT'
          DEPLOY_PROJECT_PATH='$DEPLOY_PROJECT_PATH'
          
          cd "$DEPLOY_PROJECT_PATH"
          
          echo "Current docker-compose status:"
          docker-compose ps || true
          
          echo ""
          echo "Recent logs (last 30 lines):"
          docker-compose logs --tail=30 || true
          VERIFY_SCRIPT

      - name: Deployment summary
        if: success()
        run: |
          echo "================================"
          echo "Deployment completed successfully!"
          echo "================================"
          echo ""
          echo "Project: ${{ steps.version.outputs.project-name }}"
          echo "Image: ${{ steps.version.outputs.image-uri }}"
          echo "Deploy Base: ${{ secrets.DEPLOY_PATH }}"
          echo "Server: ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}"

      - name: Deployment failed
        if: failure()
        run: |
          echo "================================"
          echo "Deployment failed!"
          echo "================================"
          echo ""
          echo "Please check the logs above for more details"
          echo ""
          echo "Common issues:"
          echo "  - SSH_PRIVATE_KEY is not formatted correctly"
          echo "  - docker-compose.yml is missing"
          echo "  - Insufficient permissions on the server"
          echo "  - GHCR_USERNAME and GHCR_PAT not configured"
          echo "  - Image is private and credentials missing"
          echo ""
          echo "To fix:"
          echo "  1. Check SSH key format (should be Ed25519 or RSA)"
          echo "  2. Verify GHCR_USERNAME and GHCR_PAT secrets exist"
          echo "  3. Ensure docker-compose.yml exists in project root"
          echo "  4. Check DB_USERNAME and DB_PASSWORD are set"
          exit 1